//version: 1707058017

import com.modrinth.minotaur.dependencies.ModDependency
import com.modrinth.minotaur.dependencies.VersionDependency

plugins {
    id 'com.gtnewhorizons.gtnhconvention'
    id 'net.darkhax.curseforgegradle' apply false
    id 'com.modrinth.minotaur' apply false
}

def final modrinthApiKey = providers.environmentVariable('MODRINTH_API_KEY')
def final cfApiKey = providers.environmentVariable('CURSEFORGE_API_KEY')

if (cfApiKey.isPresent() || deploymentDebug.toBoolean()) {
    apply plugin: 'net.darkhax.curseforgegradle'
    //noinspection UnnecessaryQualifiedReference
    tasks.register('curseforge', net.darkhax.curseforgegradle.TaskPublishCurseForge) {
        disableVersionDetection()
        debugMode = deploymentDebug.toBoolean()
        apiToken = cfApiKey.getOrElse('debug_token')

        doFirst {
            def mainFile = upload(curseForgeProjectId, reobfJar)
            def changelogFile = getChangelog()
            def changelogRaw = changelogFile.exists() ? changelogFile.getText('UTF-8') : ""

            mainFile.displayName = versionDisplayFormat.replace('$MOD_NAME', modName).replace('$VERSION', modVersion).replace('$MC_VERSION', minecraftVersion)
            mainFile.releaseType = System.getenv("RELEASE_TYPE")
            mainFile.changelog = changelogRaw
            mainFile.changelogType = 'markdown'
            mainFile.addModLoader 'Forge'
            mainFile.addJavaVersion "Java 8"
            mainFile.addGameVersion minecraftVersion

            if (curseForgeRelations.size() != 0) {
                String[] deps = curseForgeRelations.split(';')
                deps.each { dep ->
                    if (dep.size() == 0) {
                        return
                    }
                    String[] parts = dep.split(':')
                    String type = parts[0], slug = parts[1]
                    def types = [
                            'req'   : 'requiredDependency', 'required': 'requiredDependency',
                            'opt'   : 'optionalDependency', 'optional': 'optionalDependency',
                            'embed' : 'embeddedLibrary',    'embedded': 'embeddedLibrary',
                            'incomp': 'incompatible',       'fail'    : 'incompatible']
                    if (types.containsKey(type)) type = types[type]
                    if (!(type in ['requiredDependency', 'embeddedLibrary', 'optionalDependency', 'tool', 'incompatible'])) {
                        throw new Exception('Invalid Curseforge dependency type: ' + type)
                    }
                    mainFile.addRelation(slug, type)
                }
            }

            for (artifact in getSecondaryArtifacts()) {
                def additionalFile = mainFile.withAdditionalFile(artifact)
                additionalFile.changelog = changelogRaw
            }
        }
        doLast {
            // No File IDs in Debug Mode
            if (!deploymentDebug.toBoolean()) {
                def list = []
                for (def artifact : tasks.curseforge.getUploadArtifacts()) {
                    list.add(artifact)
                    for (def additionalArtifact : artifact.getAdditionalArtifacts()) {
                        list.add(additionalArtifact)
                    }
                }
                def summary = "## CurseForge Build Summary (Mod ${modName} | Project ID ${curseForgeProjectId})"
                for (def artifact : list) {
                    def fileId = artifact.getCurseFileId()
                    def fileName = artifact.getArtifact().getSingleFile().name
                    println("Uploaded File ${fileName}, With File ID: ${fileId}")
                    summary = summary + "\n  - File: ${fileName} | File ID: ${fileId}"
                }
                println(summary)
                def stepSummary = providers.environmentVariable("GITHUB_STEP_SUMMARY")
                if (stepSummary.isPresent()) {
                    file(stepSummary.get()).write(summary)
                }
            }
        }
    }
    tasks.curseforge.dependsOn(build)
    tasks.curseforge.dependsOn('generateChangelog')
}

if (modrinthApiKey.isPresent() || deploymentDebug.toBoolean()) {
    apply plugin: 'com.modrinth.minotaur'
    def final changelogFile = getChangelog()

    modrinth {
        token = modrinthApiKey.getOrElse('debug_token')
        projectId = modrinthProjectId
        versionName = versionDisplayFormat.replace('$MOD_NAME', modName).replace('$VERSION', modVersion).replace('$MC_VERSION', minecraftVersion)
        changelog = changelogFile.exists() ? changelogFile.getText('UTF-8') : ""
        versionType = System.getenv("RELEASE_TYPE")
        versionNumber = modVersion
        gameVersions = [minecraftVersion]
        loaders = ["forge"]
        debugMode = deploymentDebug.toBoolean()
        uploadFile = reobfJar
        additionalFiles = getSecondaryArtifacts()
    }
    if (modrinthRelations.size() != 0) {
        String[] deps = modrinthRelations.split(';')
        deps.each { dep ->
            if (dep.size() == 0) {
                return
            }
            String[] parts = dep.split(':')
            String[] qual = parts[0].split('-')
            addModrinthDep(qual[0], qual.length > 1 ? qual[1] : 'project', parts[1])
        }
    }
    tasks.modrinth.dependsOn(build)
    tasks.modrinth.dependsOn('generateChangelog')
}

def addModrinthDep(String scope, String type, String name) {
    com.modrinth.minotaur.dependencies.Dependency dep
    def types = [
            'req'   : 'required',
            'opt'   : 'optional',
            'embed' : 'embedded',
            'incomp': 'incompatible', 'fail': 'incompatible']
    if (types.containsKey(scope)) scope = types[scope]
    if (!(scope in ['required', 'optional', 'incompatible', 'embedded'])) {
        throw new Exception('Invalid modrinth dependency scope: ' + scope)
    }
    types = ['proj': 'project', '': 'project', 'p': 'project', 'ver': 'version', 'v': 'version']
    if (types.containsKey(type)) type = types[type]
    switch (type) {
        case 'project':
            dep = new ModDependency(name, scope)
            break
        case 'version':
            dep = new VersionDependency(name, scope)
            break
        default:
            throw new Exception('Invalid modrinth dependency type: ' + type)
    }
    project.modrinth.dependencies.add(dep)
}

def getChangelog() {
    def final changelogEnv = providers.environmentVariable('CHANGELOG_LOCATION')
    if (changelogEnv.isPresent()) {
        return new File(changelogEnv.get())
    }
    if (generateDefaultChangelog.toBoolean()) {
        return getFile('build/changelog.md')
    }
    return getFile('CHANGELOG.md')
}

def getFile(String relativePath) {
    return new File(projectDir, relativePath)
}

def getSecondaryArtifacts() {
    def secondaryArtifacts = [tasks.jar, sourcesJar]
    return secondaryArtifacts
}
